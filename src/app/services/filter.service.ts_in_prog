/*
 * Copyright 2016 Next Century Corporation
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
import { Injectable } from '@angular/core';
import * as neon from 'neon-framework';

import { TableMetaData } from '../dataset';
import { ErrorNotificationService } from './error-notification.service';
import { DatasetService } from './dataset.service';
import * as uuid from 'node-uuid';
import * as _ from 'lodash';

class Filter: {
    id: string;
    ownerId: string;
    database: string;
    table: string;
    filter: neon.query.Filter;
}

@Injectable()
export class FilterService {

    private filters: Filter[];
    private messenger: neon.eventing.Messenger;

    constructor(private errorNotificationService: ErrorNotificationService, private datasetService: DatasetService) {
        this.messenger = new neon.eventing.Messenger();
        this.filters = [];
    };

    getFilterState(onSuccess?: () => any, onError: (resp: any) => any) {
        neon.query.Filter.getFilterState('*', '*', (filters) => {
            this.filters = filters.map((filter) => {
                // TODO FINISH THIS
            });
            if (onSuccess) {
                onSuccess();
            }
        }, (response) => {
            if (onError) {
                onError(response);
            } else if (response.responseJSON) {
                this.errorNotificationService.showErrorMessage(null, response.responseJSON);
            }
        });
    };

    getFilters(comparitor: any): Filter[] {
        let matches = [];
        this.filters.forEach((filter) => {
            for (let key in Object.keys(comparitor)) {
                if (_.isEqual(comparitor[key], filter[key])) {
                    matches.push(filter);
                }
            }
        });
        return matches;
    }

    getFilterById(filterId: string): Filter {
        let matches = this.getFilters({ id: filterId });
        if (matches.length === 0) {
            return undefined;
        } else {
            return matches[0];
        }
    }

    getFiltersByOwner(ownerVisId: string) {
        return this.getFilters({ ownerId: ownerVisId });
    }

    addFilter(messenger: neon.eventing.Messenger,
        database: string,
        table: string,
        fields: string[],
        createFilterClauseFunction: (database: string, table: string, fields: string[]) => any, // TODO Change this maybe?
        filterName: any,
        ownerId: string,
        onSuccess: (resp: any) => any,
        onError: (resp: any) => any) {

        let filters = this.getFilters({
            ownerId: ownerId,
            database: database,
            table: table,
            filter:
        }); // TODO Figure the format for this out in a bit.

        if(filters.length)
    };

    createNeonFilter(database: string,
        table: string,
        filterName: string,
        createFilterClauseFunction: (database: string, table: string, fields: string[]) => any) {

        }
}
